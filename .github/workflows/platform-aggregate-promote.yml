name: Platform Aggregate & Promote

# DEMO-READY: Bi-weekly scheduled aggregation + manual triggers for hotfix capability
# PRODUCTION NOTE: Real systems would have additional approval gates and staging validation
on:
  # Bi-weekly schedule: Every second Monday at 09:00 UTC
  schedule:
    - cron: '0 9 */14 * 1'
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual platform aggregation'
        required: false
        default: 'Manual hotfix or testing'
        type: string
      create_version:
        description: "Create platform application version"
        required: false
        default: true
        type: boolean
      auto_promote:
        description: "Automatically promote through all stages to PROD"
        required: false
        default: true
        type: boolean
      preview_only:
        description: "Preview only (no writes)"
        required: false
        default: false
        type: boolean
      inventory_version:
        description: "Force inventory version (optional)"
        required: false
        type: string
      recommendations_version:
        description: "Force recommendations version (optional)"
        required: false
        type: string
      checkout_version:
        description: "Force checkout version (optional)"
        required: false
        type: string
      web_version:
        description: "Force web version (optional)"
        required: false
        type: string

jobs:
  # Use shared authentication workflow
  authenticate:
    name: "Platform Authentication"
    permissions:
      contents: read
      id-token: write
    uses: ./.github/workflows/shared-platform-auth.yml
    with:
      service-name: "aggregate-promote"
      setup-python: true
      python-version: "3.11"
      install-dependencies: true
      setup-apptrust: true

  aggregate:
    name: "Platform Aggregation"
    needs: authenticate
    runs-on: ubuntu-latest
    outputs:
      platform_version: ${{ steps.create-version.outputs.platform_version }}
      manifest_created: ${{ steps.create-version.outputs.manifest_created }}
    defaults:
      run:
        shell: bash
    env:
      # Use tokens from shared authentication workflow
      APPTRUST_BASE_URL: ${{ needs.authenticate.outputs.apptrust-base-url }}
      APPTRUST_ACCESS_TOKEN: ${{ needs.authenticate.outputs.oidc-token }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      # Note: Python, dependencies, and authentication are set up by shared workflow

      - name: "[Run] Create version and write manifest"
        id: collect-versions
        run: |
          set -euo pipefail
          ARGS="--config config/services.yaml --output-dir manifests --source-stage PROD"
          if [[ -n "${{ inputs.inventory_version }}" ]]; then ARGS="$ARGS --override inventory=${{ inputs.inventory_version }}"; fi
          if [[ -n "${{ inputs.recommendations_version }}" ]]; then ARGS="$ARGS --override recommendations=${{ inputs.recommendations_version }}"; fi
          if [[ -n "${{ inputs.checkout_version }}" ]]; then ARGS="$ARGS --override checkout=${{ inputs.checkout_version }}"; fi
          if [[ -n "${{ inputs.web_version }}" ]]; then ARGS="$ARGS --override web=${{ inputs.web_version }}"; fi
          python -m app.main $ARGS | tee release_output.txt

      - name: "[Extract] Platform version from output"
        id: create-version
        if: ${{ inputs.create_version != false && inputs.preview_only != true }}
        run: |
          set -euo pipefail
          # Extract platform version from the release output
          PLATFORM_VERSION=$(grep -o '"platform_app_version": "[^"]*"' release_output.txt | sed 's/"platform_app_version": "//; s/"//' | head -1)
          if [[ -z "$PLATFORM_VERSION" ]]; then
            echo "âŒ Could not extract platform version from output"
            exit 1
          fi
          echo "platform_version=$PLATFORM_VERSION" >> $GITHUB_OUTPUT
          echo "manifest_created=true" >> $GITHUB_OUTPUT
          echo "âœ… Platform application version created: $PLATFORM_VERSION"

      # Note: Platform aggregator doesn't publish build info
      # It only creates platform application versions via AppTrust API

      - name: "[Summary] Aggregation"
        run: |
          echo "## ðŸ—ï¸ Platform Aggregation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platform Version:** \`${{ steps.create-version.outputs.platform_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** \`${{ github.workflow }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Details" >> $GITHUB_STEP_SUMMARY
          echo "- Platform aggregation completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- Service versions collected from PROD stage" >> $GITHUB_STEP_SUMMARY
          echo "- Platform manifest generated" >> $GITHUB_STEP_SUMMARY

  promote:
    name: "Auto-Promote Platform"
    needs: aggregate
    if: ${{ needs.aggregate.outputs.manifest_created == 'true' && inputs.auto_promote != false && inputs.preview_only != true }}
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    env:
      # Prefer canonical JFrog variables used across the repo
      JFROG_URL: ${{ vars.JFROG_URL }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Auth] Persist JF access token (OIDC â†’ JFrog)"
        id: exchange-oidc
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-platform-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "âŒ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "âŒ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "âŒ Failed to exchange OIDC token" >&2; exit 1; fi
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "JF_OIDC_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "[Setup] Install dependencies"
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Note: Platform aggregator uses AppTrust API directly, no JFrog CLI needed

      - name: "[Auto-Promote] Through Stages to STAGING"
        env:
          # Set up environment variables expected by promotion library
          APPLICATION_KEY: "bookverse-platform"
          APP_VERSION: "${{ needs.aggregate.outputs.platform_version }}"
          JFROG_URL: "${{ vars.JFROG_URL }}"
          PROJECT_KEY: "${{ vars.PROJECT_KEY }}"
          APPTRUST_ACCESS_TOKEN: "${{ steps.exchange-oidc.outputs.token }}"
          STAGES_STR: "DEV QA STAGING"
          FINAL_STAGE: "STAGING"
          ALLOW_RELEASE: "false"
        run: |
          set -euo pipefail
          echo "ðŸš€ Auto-promoting platform through stages to STAGING..."
          echo "â„¹ï¸  Note: PROD release is handled by separate workflow by design"
          
          # Source the promotion library
          source .github/scripts/promote_lib.sh
          
          PLATFORM_VERSION="${{ needs.aggregate.outputs.platform_version }}"
          
          echo "ðŸ“‹ Promoting $APPLICATION_KEY@$PLATFORM_VERSION through stages..."
          echo "ðŸ”§ Environment check:"
          echo "   APPLICATION_KEY: $APPLICATION_KEY"
          echo "   APP_VERSION: $APP_VERSION"
          echo "   PROJECT_KEY: $PROJECT_KEY"
          echo "   STAGES_STR: $STAGES_STR"
          echo "   FINAL_STAGE: $FINAL_STAGE"
          echo "   ALLOW_RELEASE: $ALLOW_RELEASE"
          
          # Promote through each stage: UNASSIGNED â†’ DEV â†’ QA â†’ STAGING
          # PROD release is handled by separate workflow
          STAGES=("DEV" "QA" "STAGING")
          
          for stage in "${STAGES[@]}"; do
            echo "ðŸŽ¯ Promoting to $stage..."
            if advance_one_step; then
              echo "âœ… Successfully promoted to $stage"
            else
              echo "âŒ Failed to promote to $stage"
              exit 1
            fi
            
            # Brief pause between promotions for demo visibility
            sleep 2
          done
          
          echo "ðŸŽ‰ Platform version $PLATFORM_VERSION successfully promoted to STAGING!"
          echo "ðŸ”„ Use separate release workflow to promote to PROD when ready"

      - name: "[Summary] Promotion"
        run: |
          echo "## ðŸš€ Platform Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platform Version:** \`${{ needs.aggregate.outputs.platform_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Final Stage:** \`STAGING\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Promotion Path" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… UNASSIGNED â†’ DEV" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… DEV â†’ QA" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… QA â†’ STAGING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”„ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Use separate **Release** workflow to promote to PROD when ready" >> $GITHUB_STEP_SUMMARY
          echo "- PROD release is handled by dedicated workflow by design" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **Platform ready for STAGING validation!**" >> $GITHUB_STEP_SUMMARY
